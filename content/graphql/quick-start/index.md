+++
title = "Quick Start"
description = "Go from an empty Dgraph database to a running GraphQL API in just one step : just define the schema of your graph and how you’d like to search it; Dgraph does the rest."
weight = 2
[menu.main]
  name = "Quick Start"
  identifier = "graphql-quick-start"
  parent = "graphql"
+++

Go from an empty Dgraph database to a running GraphQL API in just one step : just define the schema of your graph and how you’d like to search it; Dgraph does the rest.

## Prerequisite
[Start a local Dgraph server](/tasks/start-dgraph-server).

When newly created and started, your Dgraph instance is already exposing GraphQL endpoints :
- a GraphQL API endpoint  at `/graphql`  
- an admin endpoint at `/admin`


## Single Step - Deploy a GraphQL Schema

We will use a simple schema involving product reviews done by customers :

```graphql
type Product {
    productID: ID!
    name: String @search(by: [term])
    reviews: [Review] @hasInverse(field: about)
}

type Customer {
    username: String! @id @search(by: [hash, regexp])
    reviews: [Review] @hasInverse(field: by)
}

type Review {
    id: ID!
    about: Product!
    by: Customer!
    comment: String @search(by: [fulltext])
    rating: Int @search
}
```

The `/admin` endpoint lets you add and update the GraphQL schema served at `/graphql`.

Take the schema above, cut-and-paste it into a file called `schema.graphql` and run the following curl command.

```
curl -X POST localhost:8080/admin/schema --data-binary '@schema.graphql'
```

Dgraph replies with errors if your schema is incorrect or with the schema it is now serving.

That's it, now you've got a GraphQL API up and running and a graph database as a backend.


## Testing your GraphQL API

You can access the GraphQL API endpoint with any of the great GraphQL developer tools.  

Good choices include
- [GraphQL Playground](https://github.com/prisma-labs/graphql-playground)
- [Insomnia](https://insomnia.rest/)
- [GraphiQL](https://github.com/graphql/graphiql)
- [Altair](https://github.com/imolorhe/altair).  

Fire one of those up and point it at `http://localhost:8080/graphql`.

Those tools have an introspection capability so you might want to explore the schema, queries and mutations that were generated by Dgraph.

### GraphQL Mutations
We'll begin by adding some products and an author.  GraphQL can accept multiple mutations at a time, so it's one request.  Neither the products nor the author will have any reviews yet, so all we need is the names.

```graphql
mutation {
  addProduct(input: [
    { name: "GraphQL on Dgraph"},
    { name: "Dgraph: The GraphQL Database"}
  ]) {
    product {
      productID
      name
    }
  }
  addCustomer(input: [{ username: "Michael"}]) {
    customer {
      username
    }
  }
}
```

The GraphQL server will return a json response like:

```json
{
  "data": {
    "addProduct": {
      "product": [
        {
          "productID": "0x2",
          "name": "GraphQL on Dgraph"
        },
        {
          "productID": "0x3",
          "name": "Dgraph: The GraphQL Database"
        }
      ]
    },
    "addCustomer": {
      "customer": [
        {
          "username": "Michael"
        }
      ]
    }
  },
  "extensions": {
    "requestID": "b155867e-4241-4cfb-a564-802f2d3808a6"
  }
}
```

And, of course, our author bought "GraphQL on Dgraph", loved it, and added a glowing review with the following mutation.  

Because the schema defined Customer with the field `username: String! @id`, the `username` field acts like an ID, so we can identify customers just with their names.  

Products, on the other hand, had `productID: ID!`, so they'll get an auto-generated ID which are returned by the mutation.

Your ID for the product might be different than `0x2`.  Make sure to use the ID from the response of the previous mutation.


```graphql
mutation {
  addReview(input: [{
    by: {username: "Michael"},
    about: { productID: "0x2"},
    comment: "Fantastic, easy to install, worked great.  Best GraphQL server available",
    rating: 10}])
  {
    review {
      comment
      rating
      by { username }
      about { name }
    }
  }
}
```

This time, the mutation result queries for the author making the review and the product being reviewed, so it's gone deeper into the graph to get the result than just the mutation data.

```json
{
  "data": {
    "addReview": {
      "review": [
        {
          "comment": "Fantastic, easy to install, worked great.  Best GraphQL server available",
          "rating": 10,
          "by": {
            "username": "Michael"
          },
          "about": {
            "name": "GraphQL on Dgraph"
          }
        }
      ]
    }
  },
  "extensions": {
    "requestID": "11bc2841-8c19-45a6-bb31-7c37c9b027c9"
  }
}
```



### GraphQL Queries

Mutations are one thing, but query is where GraphQL really shines.  With GraphQL, you get just the data you want, in a format that's suitable for your app.

With Dgraph, you get powerful graph search built into your GraphQL API.  The schema for search is generated from the schema document that we started with and automatically added to the GraphQL API for you.  

Remember the definition of a review.

```graphql
type Review {
    ...
    comment: String @search(by: [fulltext])
    ...
}
```

The directive `@search(by: [fulltext])` tells Dgraph we want to be able to search for comments with full-text search.  That's Google-style search like 'best buy' and 'loved the color'.  Dgraph took that, and the other information in the schema, and built queries and search into the API.

Let's find all the products that were easy to install.

```graphql
query {
  queryReview(filter: { comment: {alloftext: "easy to install"}}) {
    comment
    by {
      username
    }
    about {
      name
    }
  }
}
```

What reviews did you get back?  It'll depend on the data you added, but you'll at least get the initial review we added.  

Maybe you want to find reviews that describe best GraphQL products and give a high rating.

```graphql
query {
  queryReview(filter: { comment: {alloftext: "best GraphQL"}, rating: { ge: 10 }}) {
    comment
    by {
      username
    }
    about {
      name
    }
  }
}
```

How about we find the customers with names starting with "Mich" and the five products that each of those liked the most.

```graphql
query {
  queryCustomer(filter: { username: { regexp: "/Mich.*/" } }) {
    username
    reviews(order: { asc: rating }, first: 5) {
      comment
      rating
      about {
        name
      }
    }
  }
}
```
## Discussion

Dgraph allows you to have a fully functional GraphQL API in minutes with a highly performant graph backlend to serve complex nested queries.

Moreover, you can update or change your schema freely and just re-deploy new versions.

For GraphQL in Dgraph, you just concentrate on defining the schema of your graph and how you'd like to search that graph; Dgraph does the rest.  


## What's Next
- Learn more about [GraphQL schema](/graphql/schema/schema-overview/) and Dgraph directives.
- Follow our [GraphQL tutorials](https://dgraph.io/learn/) to experience rapid application development by building more advanced apps.
